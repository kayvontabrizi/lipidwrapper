## imports

# standard
import gc
import math
import sys
import typing
import warnings

# custom
import numpy
import scipy.spatial

# local
from . import multiprocessing_utils
from . import numpy_extensions
from . import molecule
from . import file_io


## methods


def load_mesh_points_and_triangulations(params: dict) -> list[molecule.Triangle]:
    pts = molecule.Molecule()
    all_triangles = None

    # could be from a PDB file
    if params["surface_filename"][-3:].upper() == "PDB":
        pts.load_pdb(params["surface_filename"])

    # could be from a blender-exported DAE file
    elif (
        params["surface_filename"][-3:].upper() == "DAE"
    ):  # this is a Collada mesh generated by blender
        f = open(params["surface_filename"], "r")
        while True:
            line = f.readline()
            if len(line) == 0:
                break  # EOF
            if (
                "<float_array" in line and "mesh-positions-array" in line
            ):  # so this is the line containing points
                pts_str = line.split(">")[1].split("<")[0].strip()
                while "  " in pts_str:
                    pts_str = pts_str.replace("  ", " ")
                pts_float = [float(t) for t in pts_str.split(" ")]
                pts_list = (
                    []
                )  # this is going to be so small that using python list is ok
                for t in range(0, len(pts_float), 3):
                    pts_list.append([pts_float[t], pts_float[t + 1], pts_float[t + 2]])
                pts.all_atoms_numpy = numpy.array(pts_list)

            if "<polylist" in line:
                # now figure out how many inputs there are and which one is the VERTEX
                line = f.readline()
                count_input = 0
                vertex_index = -1
                while "<input" in line:
                    count_input = count_input + 1
                    if "VERTEX" in line:
                        vertex_index = count_input - 1
                    line = f.readline()

                # so the next line should be vcounts
                vcounts = line.split(">")[1].split("<")[0].strip()
                while "  " in vcounts:
                    vcounts = vcounts.replace("  ", " ")
                vcounts = [int(t) for t in vcounts.split(" ")]
                all_threes = True
                for t in vcounts:
                    if t != 3:
                        all_threes = False
                        break
                if all_threes == False:
                    print(
                        "This mesh has not been triangulated. We recommend using blender. Press Ctrl-T in Edit Mode with the mesh selected."
                    )
                    sys.exit(0)

                # the next line has the triangles
                line = f.readline()
                verts = line.split(">")[1].split("<")[0].strip()
                while "  " in verts:
                    verts = verts.replace("  ", " ")
                verts = [int(t) for t in verts.split(" ")]
                all_triangles = []
                for t in range(0, len(verts), 3 * count_input):
                    pt1_index = verts[t + vertex_index]
                    pt2_index = verts[t + count_input + vertex_index]
                    pt3_index = verts[t + count_input * 2 + vertex_index]

                    pt1 = pts.all_atoms_numpy[pt1_index]
                    pt2 = pts.all_atoms_numpy[pt2_index]
                    pt3 = pts.all_atoms_numpy[pt3_index]

                    all_triangles.append([pt1, pt2, pt3])
                all_triangles = numpy.array(all_triangles)

        f.close()

    # could be from some image
    elif params["surface_filename"] != "":  # so it must be an image

        width = params["max_x"] - params["min_x"]
        height = params["max_y"] - params["min_y"]

        try:
            from PIL import Image
        except ImportError:
            print(
                "Sorry, but to use an image as the surface source, PIL must be installed..."
            )
            sys.exit(0)

        pic = Image.open(params["surface_filename"])
        pic = pic.resize((int(width), int(height)), Image.Resampling.NEAREST)
        pic = numpy.array(pic)

        pts_list = []

        for x in numpy.arange(0, width, params["step_x"]):
            for y in numpy.arange(0, height, params["step_y"]):
                z = (
                    params["max_height"] * pic[int(x), int(y), 0] / 255.0
                )  # 0 because it's R, G, B, alpha, and images should be greyscale
                pts_list.append(
                    numpy.array([x + params["min_x"], y + params["min_y"], z])
                )
        pts.all_atoms_numpy = numpy.array(pts_list)

    # could be from an equation
    else:  # so derive it from an equation
        pts_list = []
        for x in numpy.arange(params["min_x"], params["max_x"], params["step_x"]):
            for y in numpy.arange(params["min_y"], params["max_y"], params["step_y"]):
                z = 0.0
                exec(params["surface_equation"])  # to get the z value
                if not math.isnan(z):
                    pts_list.append([x, y, z])
        pts.all_atoms_numpy = numpy.array(pts_list)

    # for everything but the DAE input, a tesselation/triangulation must also be performed
    if all_triangles is None:  # so you need to get the triangulation

        # project the mesh onto the x-y plane (so it's important the it be oriented so that positive z is up)
        flatten = pts.all_atoms_numpy.copy()
        flatten = flatten[:, 0:2]

        # now tesselate the 2D points
        tri1 = scipy.spatial.Delaunay(flatten)

        # project the points back onto the mesh surface (3d trinagles)
        all_triangles = []
        for ia, ib, ic in tri1.simplices:
            all_triangles.append(
                [
                    pts.all_atoms_numpy[ia],
                    pts.all_atoms_numpy[ib],
                    pts.all_atoms_numpy[ic],
                ]
            )
        all_triangles = numpy.array(all_triangles)

    # convert this list of triangle points into a list of Triangle objects
    gc.disable()
    all_triangles_obj = []
    for tri in all_triangles:
        tri2 = molecule.Triangle(tri)
        all_triangles_obj.append(tri2)
    gc.enable()

    return all_triangles_obj


def load_lipid_model(
    params: dict,
) -> tuple[molecule.Molecule, numpy.ndarray, numpy.ndarray]:
    lipid = molecule.Molecule()
    lipid.load_pdb(params["lipid_pdb_filename"])

    # get the coordinates of the lipid headgroups
    headgroup_markers_coors = lipid.all_atoms_numpy[
        lipid.get_indices_of_mask_match(params["lipid_headgroup_marker"])
    ]

    # center the lipids and the headgroups so the x-y plane bisects the bilayer
    delta_z = numpy.array([0, 0, numpy.average(headgroup_markers_coors[:, 2])])
    lipid.all_atoms_numpy = lipid.all_atoms_numpy - delta_z
    headgroup_markers_coors = headgroup_markers_coors - delta_z

    # get the coordinates of a bounding box that encompasses the entire planar-bilayer model
    min_headgroups = numpy.amin(headgroup_markers_coors, 0)  # [x,y,z]
    max_headgroups = numpy.amax(headgroup_markers_coors, 0)  # [x,y,z]

    return lipid, min_headgroups, max_headgroups


def get_transformation_data(
    tethers1_static: numpy.ndarray, tethers2_dynamic: numpy.ndarray
) -> tuple[numpy.ndarray, numpy_extensions.Quaternion, numpy.ndarray]:
    center_tethers1_pdb = numpy.mean(tethers1_static, 0)
    center_tethers2_pdb = numpy.mean(tethers2_dynamic, 0)

    # Translate com of tether molecule to origin
    tethers1_static = tethers1_static - center_tethers1_pdb
    tethers2_dynamic = tethers2_dynamic - center_tethers2_pdb

    # Get optimal rotation
    M = numpy.dot(numpy.transpose(tethers1_static), tethers2_dynamic)

    # Create symmetric 4x4 matrix K from M
    K = numpy.array(
        [
            [
                M[0, 0] + M[1, 1] + M[2, 2],
                M[1, 2] - M[2, 1],
                M[2, 0] - M[0, 2],
                M[0, 1] - M[1, 0],
            ],
            [
                M[1, 2] - M[2, 1],
                M[0, 0] - M[1, 1] - M[2, 2],
                M[1, 0] + M[0, 1],
                M[2, 0] + M[0, 2],
            ],
            [
                M[2, 0] - M[0, 2],
                M[1, 0] + M[0, 1],
                M[1, 1] - M[0, 0] - M[2, 2],
                M[1, 2] + M[2, 1],
            ],
            [
                M[0, 1] - M[1, 0],
                M[2, 0] + M[0, 2],
                M[1, 2] + M[2, 1],
                M[2, 2] - M[0, 0] - M[1, 1],
            ],
        ]
    )

    # Find eigenvector associated with the most positive eigenvalue of K.  Multiple quaternions can
    E, V = numpy.linalg.eig(K)
    index = numpy.argmax(E)
    eigenvector = V[:, index]
    rot_quat = numpy_extensions.Quaternion(
        eigenvector[0], eigenvector[1], eigenvector[2], eigenvector[3]
    )

    return (center_tethers2_pdb, rot_quat, center_tethers1_pdb)


def apply_transformation(mol: molecule.Molecule, transform_data: tuple) -> None:
    center_dynamic_pdb = transform_data[0]
    rot_quat = transform_data[1]
    center_static_pdb = transform_data[2]

    mol.all_atoms_numpy = mol.all_atoms_numpy - center_dynamic_pdb  # move to center
    mol.rotate_mol_quat(rot_quat)  # rotate
    mol.all_atoms_numpy = (
        mol.all_atoms_numpy + center_static_pdb
    )  # move to new location


def position_lipid_model_on_triangulated_tiles(
    params: dict,
    lipid: molecule.Molecule,
    all_triangles: list[molecule.Triangle],
    min_headgroups: numpy.ndarray,
    max_headgroups: numpy.ndarray,
) -> list:
    lipid.set_undo_point()

    class position_lipids_multiprocessing(multiprocessing_utils.general_task):
        def value_func(
            self, item: tuple, results_queue: typing.Optional[typing.Any]
        ) -> None:
            params = item[0]
            lipid = item[1]
            tile_triangle = item[2]
            min_headgroups = item[3]
            max_headgroups = item[4]
            current_index = item[5]

            self.print_star_if_appropriate(current_index)

            # get the tessellated 3D triangle center and radii (r1, r2, r3, overall radius)
            tile_r1 = tile_triangle.radii()[0][0]
            tile_r2 = tile_triangle.radii()[0][1]
            tile_r3 = tile_triangle.radii()[0][2]

            # get the interior angles of the tessellated 3D triangle
            u = tile_triangle[0] - tile_triangle.center()
            v = tile_triangle[1] - tile_triangle.center()
            r1_r2_angle = molecule.angle_between(u, v)

            u = tile_triangle[0] - tile_triangle.center()
            v = tile_triangle[2] - tile_triangle.center()
            r1_r3_angle = molecule.angle_between(u, v)

            # calculate the appropriate location of an identical triangle on the user-defined planar-bilayer model. ignoring z for now (since lipid is oriented along x-y plane)
            lipid_triangle_pt1 = numpy.array([0.0, tile_r1, 0.0])
            lipid_triangle_pt2 = numpy.array(
                [
                    -tile_r2 * numpy.cos(r1_r2_angle - (numpy.pi / 2.0)),
                    -tile_r2 * numpy.sin(r1_r2_angle - (numpy.pi / 2.0)),
                    0.0,
                ]
            )
            lipid_triangle_pt3 = numpy.array(
                [
                    tile_r3 * numpy.cos(r1_r3_angle - (numpy.pi / 2.0)),
                    -tile_r3 * numpy.sin(r1_r3_angle - (numpy.pi / 2.0)),
                    0.0,
                ]
            )

            # rotate the identical triangle randomly about z axis
            random_theta = numpy.random.uniform(0, 2.0 * numpy.pi)
            rot_matrix = numpy.array(
                [
                    [numpy.cos(random_theta), numpy.sin(random_theta), 0.0],
                    [-numpy.sin(random_theta), numpy.cos(random_theta), 0.0],
                    [0.0, 0.0, 1.0],
                ]
            )
            lipid_triangle_pt1 = numpy.dot(rot_matrix, lipid_triangle_pt1)
            lipid_triangle_pt2 = numpy.dot(rot_matrix, lipid_triangle_pt2)
            lipid_triangle_pt3 = numpy.dot(rot_matrix, lipid_triangle_pt3)

            # now pick an appropriate location, and move the identical triangle to that location along x-y plane
            lipid_triangle_center_x = numpy.random.uniform(
                min_headgroups[0] + tile_triangle.max_radius(),
                max_headgroups[0] - tile_triangle.max_radius(),
            )
            lipid_triangle_center_y = numpy.random.uniform(
                min_headgroups[1] + tile_triangle.max_radius(),
                max_headgroups[1] - tile_triangle.max_radius(),
            )
            lipid_triangle_center = numpy.array(
                [lipid_triangle_center_x, lipid_triangle_center_y, 0.0]
            )
            lipid_triangle_pt1 = lipid_triangle_pt1 + lipid_triangle_center
            lipid_triangle_pt2 = lipid_triangle_pt2 + lipid_triangle_center
            lipid_triangle_pt3 = lipid_triangle_pt3 + lipid_triangle_center

            lipid_triangle = numpy.array(
                [lipid_triangle_pt1, lipid_triangle_pt2, lipid_triangle_pt3]
            )

            # now get the transformation matrix to transform the identical triangle onto the 3D tessellated triangle
            # and apply the transformation
            transform_data = get_transformation_data(
                tile_triangle.points, lipid_triangle
            )
            lipid.undo()
            apply_transformation(lipid, transform_data)

            # project the headgroups of the planar bilayer onto the identical triangle
            headgroup_markers_indices = lipid.get_indices_of_mask_match(
                params["lipid_headgroup_marker"]
            )
            headgroup_markers_coors = lipid.all_atoms_numpy[headgroup_markers_indices]
            headgroup_marker_proj_coors = tile_triangle.project_points_onto_triangle(
                headgroup_markers_coors
            )

            # identify the indices of the head groups that fall within the triangle when projected
            headgroup_indices_to_keep = numpy_extensions.get_numpy_slice(
                headgroup_markers_indices,
                tile_triangle.get_indices_of_points_within_triangle_boundaries(
                    headgroup_marker_proj_coors
                ),
            )

            # there are legitamte circumstances where no headgroups should be retained (i.e., no headgroups fall within the triangle boundaries)
            # for example, sometimes the scipy tesselation could produce "triangles" that are actually lines.
            # so abort efforts if this is the case.
            if (
                len(headgroup_indices_to_keep) == 0
                and len(headgroup_marker_proj_coors) != 0
            ):
                molecules_in_this_triangle = []
                if params["use_disk_instead_of_memory"] == "TRUE":
                    an_id = file_io.save_pickle(molecules_in_this_triangle, params)
                    self.results.append((tile_triangle, an_id))
                else:
                    self.results.append((tile_triangle, molecules_in_this_triangle))
                return

            # identify the indices of the head groups that fall within a smaller triangle, that are too far from the edges to worry about steric clashes in subsequent steps.
            # this speeds up subsequent steps significantly
            smaller_tri = tile_triangle.new_triangle_expanded_by_margin(
                -params["clashing_potential_margin"]
            )
            todel = smaller_tri.get_indices_of_points_within_triangle_boundaries(
                headgroup_marker_proj_coors
            )
            headgroup_indices_not_in_triangle_margin = numpy_extensions.get_numpy_slice(
                headgroup_markers_indices, todel
            )

            # identify the indices of the head groups that fall within an even smaller triangle, called the submargin.
            # identifying these headgroups will speed up the lipid-filling step later. Lipids will be placed in the margin, and the steric clashes are checked with the lipids of the submargin (as well as the margins of neighboring triangles)
            smaller_still_tri = smaller_tri.new_triangle_expanded_by_margin(
                -params["clashing_potential_margin"]
            )
            todel = smaller_still_tri.get_indices_of_points_within_triangle_boundaries(
                headgroup_marker_proj_coors
            )
            headgroup_indices_not_in_triangle_margin_or_submargin = (
                numpy_extensions.get_numpy_slice(headgroup_markers_indices, todel)
            )

            # now get the entire lipids corresponding to these headgroups
            molecules_in_this_triangle = []

            # first, identify all residues
            atom_counts = len(lipid.atom_inf_resids)

            all_ids = numpy.char.add(
                lipid.atom_inf_string_vals[:, 0], numpy.array(["_"] * atom_counts)
            )
            all_ids = numpy.char.add(all_ids, lipid.atom_inf_resids)
            all_ids = numpy.char.add(all_ids, numpy.array(["_"] * atom_counts))
            all_ids = numpy.char.add(all_ids, lipid.atom_inf_string_vals[:, 1])

            # now identify all residues to keep
            atom_counts = len(headgroup_indices_to_keep)
            if atom_counts != 0:
                hg_ids = numpy.char.add(
                    lipid.atom_inf_string_vals[headgroup_indices_to_keep, 0],
                    numpy.array(["_"] * atom_counts),
                )
                hg_ids = numpy.char.add(
                    hg_ids, lipid.atom_inf_resids[headgroup_indices_to_keep]
                )
                hg_ids = numpy.char.add(hg_ids, numpy.array(["_"] * atom_counts))
                hg_ids = numpy.char.add(
                    hg_ids, lipid.atom_inf_string_vals[headgroup_indices_to_keep, 1]
                )
            else:
                hg_ids = numpy.array([])

            # now identify all residues to never delete (inside inner triangle)
            atom_counts = len(headgroup_indices_not_in_triangle_margin)
            if atom_counts != 0:
                hg_ids_not_in_triangle_margin = numpy.char.add(
                    lipid.atom_inf_string_vals[
                        headgroup_indices_not_in_triangle_margin, 0
                    ],
                    numpy.array(["_"] * atom_counts),
                )
                hg_ids_not_in_triangle_margin = numpy.char.add(
                    hg_ids_not_in_triangle_margin,
                    lipid.atom_inf_resids[headgroup_indices_not_in_triangle_margin],
                )
                hg_ids_not_in_triangle_margin = numpy.char.add(
                    hg_ids_not_in_triangle_margin, numpy.array(["_"] * atom_counts)
                )
                hg_ids_not_in_triangle_margin = numpy.char.add(
                    hg_ids_not_in_triangle_margin,
                    lipid.atom_inf_string_vals[
                        headgroup_indices_not_in_triangle_margin, 1
                    ],
                )
            else:
                hg_ids_not_in_triangle_margin = numpy.array([])

            # now identify all residues that are even interior to the submargin
            atom_counts = len(headgroup_indices_not_in_triangle_margin_or_submargin)
            if atom_counts != 0:
                hg_ids_not_in_triangle_margin_or_submargin = numpy.char.add(
                    lipid.atom_inf_string_vals[
                        headgroup_indices_not_in_triangle_margin_or_submargin, 0
                    ],
                    numpy.array(["_"] * atom_counts),
                )
                hg_ids_not_in_triangle_margin_or_submargin = numpy.char.add(
                    hg_ids_not_in_triangle_margin_or_submargin,
                    lipid.atom_inf_resids[
                        headgroup_indices_not_in_triangle_margin_or_submargin
                    ],
                )
                hg_ids_not_in_triangle_margin_or_submargin = numpy.char.add(
                    hg_ids_not_in_triangle_margin_or_submargin,
                    numpy.array(["_"] * atom_counts),
                )
                hg_ids_not_in_triangle_margin_or_submargin = numpy.char.add(
                    hg_ids_not_in_triangle_margin_or_submargin,
                    lipid.atom_inf_string_vals[
                        headgroup_indices_not_in_triangle_margin_or_submargin, 1
                    ],
                )
            else:
                hg_ids_not_in_triangle_margin_or_submargin = numpy.array([])

            # remove the lipids that are beyond the bounds of this triangle to speed up subsequent searching
            # Find the indices of elements of all_ids that are in hg_ids.
            iall_ids = numpy.isin(all_ids.ravel(), hg_ids).reshape(all_ids.shape)
            indices_of_lipids_to_keep = numpy.where(iall_ids)[0]
            lipid = lipid.portion_of(indices_of_lipids_to_keep)
            all_ids = all_ids[indices_of_lipids_to_keep]

            # find where to split this lipid model into individual lipids
            all_ids_offset = all_ids.copy()
            all_ids_offset = numpy.append(all_ids_offset, all_ids_offset[0])
            all_ids_offset = all_ids_offset[
                numpy.arange(1, len(all_ids_offset), dtype=int)
            ]
            indices_of_each_lipid = (
                1 + numpy.nonzero(numpy.logical_not(all_ids == all_ids_offset))[0]
            )
            indices_of_each_lipid = numpy.insert(indices_of_each_lipid, 0, 0)

            # now move each individual lipid into its own object and append
            gc.disable()  # because appending objects
            for t in range(len(indices_of_each_lipid) - 1):
                start_index = indices_of_each_lipid[t]
                end_index = indices_of_each_lipid[t + 1]
                atom_range = numpy.arange(start_index, end_index, dtype=int)
                single_lipid = lipid.portion_of(atom_range)
                single_lipid.in_triangle_submargin = False
                single_lipid.in_triangle_margin = True

                with warnings.catch_warnings():
                    warnings.simplefilter(action="ignore", category=FutureWarning)

                    if all_ids[start_index] in hg_ids_not_in_triangle_margin:
                        single_lipid.in_triangle_margin = False

                        if (
                            not all_ids[start_index]
                            in hg_ids_not_in_triangle_margin_or_submargin
                        ):
                            single_lipid.in_triangle_submargin = True

                    molecules_in_this_triangle.append(single_lipid)

            if params["use_disk_instead_of_memory"] == "TRUE":
                an_id = file_io.save_pickle(molecules_in_this_triangle, params)
                self.results.append((tile_triangle, an_id))
            else:
                self.results.append((tile_triangle, molecules_in_this_triangle))

            gc.enable()

    input_array = [
        (params, lipid, tile_triangle, min_headgroups, max_headgroups, index + 1)
        for index, tile_triangle in enumerate(all_triangles)
    ]
    tmp = multiprocessing_utils.multi_threading(
        input_array,
        params["number_of_processors"],
        position_lipids_multiprocessing,
        params,
        "REMARK ",
    )

    molecules_by_triangle = tmp.results

    return molecules_by_triangle
